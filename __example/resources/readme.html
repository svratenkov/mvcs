<link rel="stylesheet" href="https://stackedit.io/style.css" />
 <style>
	pre {
		-o-tab-size: 4;		/* Opera */
		-moz-tab-size: 4;	/* Firefox */
		tab-size: 4;
	}
 </style>

<div class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#mvcs-model-view-controller-scenario">MVCS (Model-View-Controller-Scenario)</a>
<ul>
<li><a href="#mvcs-concepts">MVCS concepts</a>
<ul>
<li><a href="#modern-frameworks-shortcomings">Modern frameworks shortcomings</a></li>
<li><a href="#view-is-a-renderer">View is a renderer</a></li>
<li><a href="#viewmodel-vs-domainmodel">ViewModel vs DomainModel</a></li>
<li><a href="#scenario-vs-fat-controller">Scenario vs fat controller</a></li>
<li><a href="#mvc--mvcs-comparison">MVC / MVCS comparison</a></li>
</ul>
</li>
<li><a href="#mvcs-components">MVCS components</a>
<ul>
<li><a href="#scenario">Scenario</a>
<ul>
<li><a href="#scenario-examples">Scenario examples</a></li>
<li><a href="#mvcs-controller">MVCS controller</a></li>
<li><a href="#mvcs-container-and-resolver">MVCS container and resolver</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="mvcs-model-view-controller-scenario">MVCS (Model-View-Controller-Scenario)</h1>
<h2 id="mvcs-concepts">MVCS concepts</h2>
<h3 id="modern-frameworks-shortcomings">Modern frameworks shortcomings</h3>
<p>Let’s look at typical modern frameworks <em>“fat controller”</em> implementation:</p>
<pre class=" language-php"><code class="prism  language-php"><span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token keyword">extends</span> <span class="token class-name">Controller</span>
<span class="token punctuation">{</span>
	<span class="token comment">// Display user info for given user ID</span>
	<span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">actionUserInfo</span><span class="token punctuation">(</span><span class="token variable">$user_id</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// Retrieve first and last user names from database</span>
		<span class="token variable">$user</span> <span class="token operator">=</span> User<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token variable">$user_id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// View template needs full user name - compile it</span>
		<span class="token variable">$name</span> <span class="token operator">=</span> <span class="token variable">$user</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">firstName</span><span class="token punctuation">.</span><span class="token string">' '</span><span class="token punctuation">.</span><span class="token variable">$user</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token property">lastName</span><span class="token punctuation">;</span>

		<span class="token comment">// Create view with hard-coded template and compiled data</span>
		<span class="token variable">$view</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">View</span><span class="token punctuation">(</span><span class="token string">'user_info'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Render and return</span>
		<span class="token keyword">return</span> <span class="token variable">$view</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>What we see here is an easy to cook, but hard to eat MVC salad. We see <em><strong>Model presence in the Controller</strong></em>. We see template name <em><strong>hard-coded in the Controller</strong></em>, we need to recode to change it. We can’t change the <em><strong>rendering method</strong></em>, for example from html to pdf, we need to develop special view class for pdf rendering.</p>
<blockquote>
<p>Modern frameworks have some common shortcomings in their MVC implementation:</p>
<ol>
<li>Narrow treating of View component as a <em>“PHP file template renderer”</em> <em><strong>only</strong></em> instead of something like <em>“any renderer”</em>.</li>
<li>Narrow treating of Model component as a Database component <em><strong>only</strong></em> instead of something like <em>“any data gatherer”</em>.</li>
<li>Provoking to use so called <em>“fat controllers”</em> when controller contains altogether business, presentation and interaction logics. This totally violates the main MVC goal to separate concerns between it’s components triad.</li>
</ol>
</blockquote>
<p>To resolve this gaps we should define Model, View, Controller components responsibilities more carefully.</p>
<h3 id="view-is-a-renderer">View is a renderer</h3>
<p>Let’s look at the first gap:</p>
<blockquote>
<ol>
<li>Narrow treating of View component as a <em>“PHP file template renderer”</em> <em><strong>only</strong></em> instead of something like <em>“any renderer”</em>.</li>
</ol>
</blockquote>
<p>To resolve this gap we need only to say that any view may use any renderer. To implement this we need to add <code>renderer</code> property to a View class:</p>
<pre class=" language-php"><code class="prism  language-php"><span class="token keyword">class</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token variable">$template</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">,</span> <span class="token variable">$renderer</span><span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__costruct</span><span class="token punctuation">(</span><span class="token variable">$template</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">,</span> <span class="token variable">$renderer</span> <span class="token operator">=</span> <span class="token keyword">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We have stated that renderer is an important component of the view. <strong>Renderer is a callable</strong> that renders given data using given template.</p>
<p>We can also say that the view itself is a renderer, moreover it is a specific renderer which holds it’s own template, data and even renderer.</p>
<p>Most applications use only one renderer, and even if they use multiple then they have some default renderer. That’s why we defined renderer arg in the View constructor as optional, assuming an existence of some application default renderer.</p>
<h3 id="viewmodel-vs-domainmodel">ViewModel vs DomainModel</h3>
<p>Let’s look at the second gap:</p>
<blockquote>
<ol start="2">
<li>Narrow treating of Model component as a Database component <em><strong>only</strong></em> instead of something like <em>“any data gatherer”</em>.</li>
</ol>
</blockquote>
<p>It is obvious that data saved in the database nearly never corresponds to data needs for a concrete template. Database data is really a base for a lot of different templates. This is called as DomainModel data and a ViewModel data, where DomainModel is a database level data, while ViewModel is a data for the concrete view. And we always need to convert domain data to view data.</p>
<p>As modern frameworks does not have ViewModel components, the simplest way is to convert domain data in the controller. And to violate basic MVC principles.</p>
<p>So to implement MVC we have to define ViewModel. The direct way is to implement ViewModel as a callable that converts input domain data to an output model data.</p>
<h3 id="scenario-vs-fat-controller">Scenario vs fat controller</h3>
<p>Let’s look at the third gap:</p>
<blockquote>
<ol start="3">
<li>Provoking to use so called <em>“fat controllers”</em> when controller contains altogether business, presentation and interaction logics. This violates the main MVC goal to separate concerns between it’s components triad.</li>
</ol>
</blockquote>
<p>As we already delegated business logics to a Model, presentation to a View (i.e. renderer), then the only responsibility remains  is the interaction logics  and it should be assigned to the Controller. This task looks extremely diverse, but it only looks so.</p>
<p>If we examine any request flow we will find a simple chain of some consecutive steps. Most of them are common for different requests, others could be unique for some requests only. Nevertheless all of them are steps.</p>
<p>Each step is simply a data converter. Client-Server application could be considered as a single high level converter of app request data to app response data. This high level converter may consist of some lower level   chained converters, such as:</p>
<ul>
<li>DomainModel converts application request to raw domain data,</li>
<li>ViewModel converts domain data to view data,</li>
<li>View converts view data to an application response (by rendering view data according to view template).</li>
</ul>
<p>There could be specific “converters” like redirects, data validators, ajax exits, so on.</p>
<p>We will call such converters chain as <code>scenario</code> and each step in the chain as a <code>scenario action</code>.</p>
<h3 id="mvc--mvcs-comparison">MVC / MVCS comparison</h3>
<p>MVCS is a variation of MVC pattern. The main difference lies in further separation of concerns and correspondent refinement of all MVC components roles.</p>
<ul>
<li>MVC <code>Model</code>-<code>View</code> interactions refinement. MVCS defines special component <code>Scenario</code> for handling such interactions. <code>Scenario</code> can define any set of actions to transform app request to app response. For example: popular <code>ViewModel</code> component is a natural action in a common <code>model &gt; viewmodel &gt; view</code> scenario chain.</li>
<li>MVC <code>View</code> component is actually a kind of MVCS renderer.</li>
<li>MVCS <code>Controller</code> controls <code>scenarios</code> rather than <code>Model</code>-<code>View</code> interactions (which are controlled by <code>scenarios</code>). For example: we can implement so called Layout View with some special LayoutController which will send the response of main scenario to a special app layout scenario.</li>
<li>Any MVCS component (<code>scenario</code>, <code>scenario action</code>, <code>renderer</code>) could be stored in the scenario container.</li>
</ul>
<h2 id="mvcs-components">MVCS components</h2>
<h3 id="scenario">Scenario</h3>
<p>Scenario is a base MVCS component. It is an analog of an MVC’s controller action. Due to scenarios MVCS does not need any customizable controller actions, so MVCS Controller is an immutable internal class.</p>
<p>Scenario is a chain of primitive actions. Each action is simply a data converter. It converts its input data to an output data. Those output data became an input to the next chained action.</p>
<p>And the scenario itself acts as a single converter which converts application request to an application response.</p>
<h4 id="scenario-examples">Scenario examples</h4>
<p>String format (suitable for RegEx routers):</p>
<pre class=" language-php"><code class="prism  language-php"><span class="token comment">// 2 actions: UserModel::list getter &amp; render with 'user/list' template</span>
<span class="token string">'user:list &gt; render,user/list'</span>

<span class="token comment">// 2 actions: UserModel::role getter &amp; (ajax) exit</span>
<span class="token string">'user:role &gt; exit'</span>

<span class="token comment">// 2 actions: UserModel::login getter &amp; redirect to 'success' page</span>
<span class="token string">'user:login &gt; redirect,success'</span>
</code></pre>
<p>The same in an array format:</p>
<pre class=" language-php"><code class="prism  language-php"><span class="token punctuation">[</span><span class="token string">'user:list'</span><span class="token punctuation">,</span> <span class="token string">'render,user/list'</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>The same in a base format:</p>
<pre class=" language-php"><code class="prism  language-php"><span class="token comment">// Any string or array definition of actions chain</span>
<span class="token variable">$definition</span> <span class="token operator">=</span> <span class="token string">'user:list &gt; render,user/list'</span><span class="token punctuation">;</span>
<span class="token variable">$scenario</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scenario</span><span class="token punctuation">(</span><span class="token variable">$definition</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
``

<span class="token shell-comment comment">#### Scenario actions</span>

Scenario action is any callable which converts its input data <span class="token keyword">array</span> to an output data <span class="token keyword">array</span><span class="token punctuation">.</span> Scenario action accepts one required argument <span class="token keyword">for</span> input data <span class="token keyword">and</span> optional variadic parameters list<span class="token punctuation">:</span>
```php
<span class="token variable">$scenarioAction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$input</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token variable">$params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>Scenario action should return an output data array.</p>
<p>There are some specifics in scenario actions.</p>
<ul>
<li>The <em>first</em> action in the chain is a data <code>compiler</code>. It is an analog of the MVC <code>Model</code> component. It retrieves domain model (database) data according to model state given by request parameters. Compiler accepts application request parameters which are not an associative data array, but are a consecutive list of request parameters.</li>
<li>The <em>last</em> action in the chain is a data <code>decorator</code> returning string application response rather then associative data array. It is an analog of the MVC <code>View</code> component.</li>
<li>Any <em>intermediate</em> action is called <code>filter</code> and they accept and return an associative data array. Any <code>filter</code> usually converts input data to an output and acts as <code>ViewModel</code> which prepares data for any concrete view. But <code>filters</code> can also perform data validation, redirects, ajax exits, json encoding or anything else.</li>
</ul>
<h4 id="mvcs-controller">MVCS controller</h4>
<p>As noted above MVCS <code>controller</code> doesn’t have model-view interactions responsibilities, which are delegated to an MVCS <code>scenario</code>. MVCS <code>controller</code>'s main and highly important responsibility is to deal with application and isolate MVCS module from any application specifics.</p>
<p>Most significant responsibilities of MVCS <code>controller</code> are:</p>
<ul>
<li>Retrieve <code>scenario</code> and <code>scenario parameters</code> from the application, usually from the router.</li>
<li>Create <code>scenario</code> instance and play it with given <code>scenario parameters</code>.</li>
<li>Return <code>scenario</code> response back to application.</li>
<li>Maintain MVCS container.</li>
</ul>
<h4 id="mvcs-container-and-resolver">MVCS container and resolver</h4>
<p>MVCS module uses container to hold all the scenarios items and their unique names (aliases). These items are application specific models, renderers and actions.</p>
<p>Scenario container uses any external PSR Container which implements two methods: get() and  has(). It uses it’s internal container if an external is not given.</p>
<p>MVCS has container items resolver to support resolving of various kinds of callable definitions. MVCS resolver can resolve some special keys:</p>
<ul>
<li>‘keyalias’ is a key of another container entry.</li>
<li>‘key:method’ is a special key pattern for some method of some class or object.</li>
</ul>

    </div>
  </div>
</div>
